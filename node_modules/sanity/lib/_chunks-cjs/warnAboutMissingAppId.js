"use strict";
var path = require("node:path"), resolveFrom = require("resolve-from"), semver = require("semver"), fs = require("node:fs/promises"), chalk = require("chalk"), logSymbols = require("log-symbols");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var path__default = /* @__PURE__ */ _interopDefaultCompat(path), resolveFrom__default = /* @__PURE__ */ _interopDefaultCompat(resolveFrom), semver__default = /* @__PURE__ */ _interopDefaultCompat(semver), chalk__default = /* @__PURE__ */ _interopDefaultCompat(chalk);
const MODULES_HOST = process.env.SANITY_MODULES_HOST || (process.env.SANITY_INTERNAL_ENV === "staging" ? "https://sanity-cdn.work" : "https://sanity-cdn.com");
function currentUnixTime() {
  return Math.floor(Date.now() / 1e3);
}
function getAutoUpdatesImportMap(packages, options = {}) {
  return Object.fromEntries(packages.flatMap((pkg) => getAppAutoUpdateImportMapForPackage(pkg, options)));
}
function getAppAutoUpdateImportMapForPackage(pkg, options = {}) {
  const moduleUrl = getModuleUrl(pkg, options);
  return [[pkg.name, moduleUrl], [`${pkg.name}/`, `${moduleUrl}/`]];
}
function getModuleUrl(pkg, options = {}) {
  const {
    timestamp = currentUnixTime()
  } = options;
  return options.appId ? getByAppModuleUrl(pkg, {
    appId: options.appId,
    baseUrl: options.baseUrl,
    timestamp
  }) : getLegacyModuleUrl(pkg, {
    timestamp,
    baseUrl: options.baseUrl
  });
}
function getLegacyModuleUrl(pkg, options) {
  const encodedMinVer = encodeURIComponent(`^${pkg.version}`);
  return `${options.baseUrl || MODULES_HOST}/v1/modules/${rewriteScopedPackage(pkg.name)}/default/${encodedMinVer}/t${options.timestamp}`;
}
function getByAppModuleUrl(pkg, options) {
  const encodedMinVer = encodeURIComponent(`^${pkg.version}`);
  return `${options.baseUrl || MODULES_HOST}/v1/modules/by-app/${options.appId}/t${options.timestamp}/${encodedMinVer}/${rewriteScopedPackage(pkg.name)}`;
}
function rewriteScopedPackage(pkgName) {
  if (!pkgName.includes("@"))
    return pkgName;
  const [scope, ...pkg] = pkgName.split("/");
  return `${scope}__${pkg.join("")}`;
}
function isPackageManifest(item) {
  return typeof item == "object" && item !== null && "name" in item && "version" in item;
}
async function readPackageJson(filePath) {
  try {
    return JSON.parse(await fs.readFile(filePath, "utf8"));
  } catch (err) {
    throw new Error(`Failed to read "${filePath}": ${err.message}`);
  }
}
async function readPackageManifest(packageJsonPath, defaults = {}) {
  let manifest;
  try {
    manifest = {
      ...defaults,
      ...await readPackageJson(packageJsonPath)
    };
  } catch (err) {
    throw new Error(`Failed to read "${packageJsonPath}": ${err.message}`);
  }
  if (!isPackageManifest(manifest))
    throw new Error(`Failed to read "${packageJsonPath}": Invalid package manifest`);
  const {
    name,
    version,
    dependencies = {},
    devDependencies = {}
  } = manifest;
  return {
    name,
    version,
    dependencies,
    devDependencies
  };
}
function getRemoteResolvedVersion(fetchFn, url) {
  return fetchFn(url, {
    method: "HEAD",
    redirect: "manual"
  }).then((res) => {
    if (res.ok || res.status < 400) {
      const resolved = res.headers.get("x-resolved-version");
      if (!resolved)
        throw new Error(`Missing 'x-resolved-version' header on response from HEAD ${url}`);
      return resolved;
    }
    throw new Error(`Unexpected HTTP response: ${res.status} ${res.statusText}`);
  }, (err) => {
    throw new Error(`Failed to fetch remote version for ${url}: ${err.message}`, {
      cause: err
    });
  });
}
async function compareDependencyVersions(packages, workDir, {
  fetchFn = globalThis.fetch
} = {}) {
  const manifest = await readPackageManifest(path__default.default.join(workDir, "package.json")), dependencies = {
    ...manifest.dependencies,
    ...manifest.devDependencies
  }, failedDependencies = [];
  for (const pkg of packages) {
    const resolvedVersion = await getRemoteResolvedVersion(fetchFn, getModuleUrl(pkg)), manifestPath = resolveFrom__default.default.silent(workDir, path__default.default.join(pkg.name, "package.json")), manifestVersion = dependencies[pkg.name], installed = semver__default.default.coerce(manifestPath ? semver__default.default.parse((await readPackageManifest(manifestPath)).version) : semver__default.default.coerce(manifestVersion));
    if (!installed)
      throw new Error(`Failed to parse installed version for ${pkg}`);
    semver__default.default.eq(resolvedVersion, installed.version) || failedDependencies.push({
      pkg: pkg.name,
      installed: installed.version,
      remote: resolvedVersion
    });
  }
  return failedDependencies;
}
async function readModuleVersion(dir, moduleName) {
  const manifestPath = resolveFrom__default.default.silent(dir, path__default.default.join(moduleName, "package.json"));
  return manifestPath ? (await readPackageManifest(manifestPath)).version : null;
}
function shouldAutoUpdate({
  flags,
  cliConfig,
  output
}) {
  if ("auto-updates" in flags) {
    if (output) {
      const flagUsed = flags["auto-updates"] ? "--auto-updates" : "--no-auto-updates";
      output.warn(chalk__default.default.yellow(`The ${flagUsed} flag is deprecated for \`deploy\` and \`build\` commands. Set the \`autoUpdates\` option in \`sanity.cli.ts\` or \`sanity.cli.js\` instead.`));
    }
    return !!flags["auto-updates"];
  }
  const hasOldCliConfigFlag = cliConfig && "autoUpdates" in cliConfig, hasNewCliConfigFlag = cliConfig && "deployment" in cliConfig && cliConfig.deployment && "autoUpdates" in cliConfig.deployment;
  if (hasOldCliConfigFlag && hasNewCliConfigFlag)
    throw new Error("Found both `autoUpdates` (deprecated) and `deployment.autoUpdates` in sanity.cli.js. Please remove the deprecated top level `autoUpdates` config.");
  return hasOldCliConfigFlag && output?.warn(chalk__default.default.yellow(`The \`autoUpdates\` config has moved to \`deployment.autoUpdates\`.
Please update \`sanity.cli.ts\` or \`sanity.cli.js\` and make the following change:
${chalk__default.default.red(`-  autoUpdates: ${cliConfig.autoUpdates},`)}
${chalk__default.default.green(`+  deployment: {autoUpdates: ${cliConfig.autoUpdates}}}`)}
`)), !!(hasOldCliConfigFlag ? cliConfig.autoUpdates : cliConfig?.deployment?.autoUpdates);
}
const baseUrl = process.env.SANITY_INTERNAL_ENV === "staging" ? "https://sanity.work" : "https://sanity.io";
function warnAboutMissingAppId({
  appType,
  projectId,
  output,
  cliConfigPath
}) {
  const manageUrl = `${baseUrl}/manage${projectId ? `/project/${projectId}/studios` : ""}`, cliConfigFile = cliConfigPath ? path__default.default.basename(cliConfigPath) : "sanity.cli.js";
  output.print(`${logSymbols.warning} No ${chalk__default.default.bold("appId")} configured. This ${appType} will auto-update to the ${chalk__default.default.green.bold("latest")} channel. To enable fine grained version selection, head over to ${chalk__default.default.cyan(manageUrl)} and add the appId to the ${chalk__default.default.bold("deployment")} section in ${chalk__default.default.bold(cliConfigFile)}.
        `);
}
exports.compareDependencyVersions = compareDependencyVersions;
exports.getAutoUpdatesImportMap = getAutoUpdatesImportMap;
exports.readModuleVersion = readModuleVersion;
exports.readPackageJson = readPackageJson;
exports.readPackageManifest = readPackageManifest;
exports.shouldAutoUpdate = shouldAutoUpdate;
exports.warnAboutMissingAppId = warnAboutMissingAppId;
//# sourceMappingURL=warnAboutMissingAppId.js.map
