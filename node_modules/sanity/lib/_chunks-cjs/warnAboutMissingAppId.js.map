{"version":3,"file":"warnAboutMissingAppId.js","sources":["../../src/_internal/cli/util/getAutoUpdatesImportMap.ts","../../src/_internal/cli/util/readPackageManifest.ts","../../src/_internal/cli/util/compareDependencyVersions.ts","../../src/_internal/cli/util/readModuleVersion.ts","../../src/_internal/cli/util/shouldAutoUpdate.ts","../../src/_internal/cli/util/baseUrl.ts","../../src/_internal/cli/util/warnAboutMissingAppId.ts"],"sourcesContent":["const MODULES_HOST =\n  process.env.SANITY_MODULES_HOST ||\n  (process.env.SANITY_INTERNAL_ENV === 'staging'\n    ? 'https://sanity-cdn.work'\n    : 'https://sanity-cdn.com')\n\nfunction currentUnixTime(): number {\n  return Math.floor(Date.now() / 1000)\n}\n\ntype Package = {version: string; name: string}\n/**\n * @internal\n */\nexport function getAutoUpdatesImportMap<const Pkg extends Package>(\n  packages: Pkg[],\n  options: {timestamp?: number; baseUrl?: string; appId?: string} = {},\n) {\n  return Object.fromEntries(\n    packages.flatMap((pkg) => getAppAutoUpdateImportMapForPackage(pkg, options)),\n  ) as {[K in Pkg['name'] | `${Pkg['name']}/`]: string}\n}\n\nfunction getAppAutoUpdateImportMapForPackage<const Pkg extends Package>(\n  pkg: Pkg,\n  options: {timestamp?: number; baseUrl?: string; appId?: string} = {},\n): [[Pkg['name'], string], [`${Pkg['name']}/`, string]] {\n  const moduleUrl = getModuleUrl(pkg, options)\n\n  return [\n    [pkg.name, moduleUrl],\n    [`${pkg.name}/`, `${moduleUrl}/`],\n  ]\n}\n\nexport function getModuleUrl(\n  pkg: Package,\n  options: {timestamp?: number; baseUrl?: string; appId?: string} = {},\n) {\n  const {timestamp = currentUnixTime()} = options\n  return options.appId\n    ? getByAppModuleUrl(pkg, {appId: options.appId, baseUrl: options.baseUrl, timestamp})\n    : getLegacyModuleUrl(pkg, {timestamp, baseUrl: options.baseUrl})\n}\n\nfunction getLegacyModuleUrl(pkg: Package, options: {timestamp: number; baseUrl?: string}) {\n  const encodedMinVer = encodeURIComponent(`^${pkg.version}`)\n  return `${options.baseUrl || MODULES_HOST}/v1/modules/${rewriteScopedPackage(pkg.name)}/default/${encodedMinVer}/t${options.timestamp}`\n}\n\nfunction getByAppModuleUrl(\n  pkg: Package,\n  options: {appId: string; baseUrl?: string; timestamp: number},\n) {\n  const encodedMinVer = encodeURIComponent(`^${pkg.version}`)\n  return `${options.baseUrl || MODULES_HOST}/v1/modules/by-app/${options.appId}/t${options.timestamp}/${encodedMinVer}/${rewriteScopedPackage(pkg.name)}`\n}\n\n/**\n * replaces '/' with '__' similar to how eg `@types/scope__pkg` are rewritten\n * scoped packages are stored this way both in the manifest and in the cloud storage bucket\n */\nfunction rewriteScopedPackage(pkgName: string) {\n  if (!pkgName.includes('@')) {\n    return pkgName\n  }\n  const [scope, ...pkg] = pkgName.split('/')\n  return `${scope}__${pkg.join('')}`\n}\n","import {readFile} from 'node:fs/promises'\n\nimport {type PackageJson} from '@sanity/cli'\n\ninterface DependencyDeclarations {\n  dependencies: Record<string, string | undefined>\n  devDependencies: Record<string, string | undefined>\n}\n\ninterface PackageManifest extends DependencyDeclarations {\n  name: string\n  version: string\n}\n\nexport interface PartialPackageManifest extends Partial<DependencyDeclarations> {\n  name: string\n  version: string\n}\n\nfunction isPackageManifest(item: unknown): item is PartialPackageManifest {\n  return typeof item === 'object' && item !== null && 'name' in item && 'version' in item\n}\n\n/**\n * Read the `package.json` file at the given path\n *\n * @param filePath - Path to package.json to read\n * @returns The parsed package.json\n */\nexport async function readPackageJson(filePath: string): Promise<PackageJson> {\n  try {\n    return JSON.parse(await readFile(filePath, 'utf8'))\n  } catch (err) {\n    throw new Error(`Failed to read \"${filePath}\": ${err.message}`)\n  }\n}\n/**\n * Read the `package.json` file at the given path and return an object that guarantees\n * the presence of name, version, dependencies, dev dependencies and peer dependencies\n *\n * @param packageJsonPath - Path to package.json to read\n * @returns Reduced package.json with guarantees for name, version and dependency fields\n */\nexport async function readPackageManifest(\n  packageJsonPath: string,\n  defaults: Partial<PartialPackageManifest> = {},\n): Promise<PackageManifest> {\n  let manifest: unknown\n  try {\n    manifest = {...defaults, ...(await readPackageJson(packageJsonPath))}\n  } catch (err) {\n    throw new Error(`Failed to read \"${packageJsonPath}\": ${err.message}`)\n  }\n\n  if (!isPackageManifest(manifest)) {\n    throw new Error(`Failed to read \"${packageJsonPath}\": Invalid package manifest`)\n  }\n\n  const {name, version, dependencies = {}, devDependencies = {}} = manifest\n  return {name, version, dependencies, devDependencies}\n}\n","import path from 'node:path'\n\nimport resolveFrom from 'resolve-from'\nimport semver from 'semver'\n\nimport {getModuleUrl} from './getAutoUpdatesImportMap'\nimport {readPackageManifest} from './readPackageManifest'\n\nfunction getRemoteResolvedVersion(fetchFn: typeof fetch, url: string) {\n  return fetchFn(url, {\n    method: 'HEAD',\n    redirect: 'manual',\n  }).then(\n    (res) => {\n      // 302 is expected, but lets also handle 2xx\n      if (res.ok || res.status < 400) {\n        const resolved = res.headers.get('x-resolved-version')\n        if (!resolved) {\n          throw new Error(`Missing 'x-resolved-version' header on response from HEAD ${url}`)\n        }\n        return resolved\n      }\n      throw new Error(`Unexpected HTTP response: ${res.status} ${res.statusText}`)\n    },\n    (err) => {\n      throw new Error(`Failed to fetch remote version for ${url}: ${err.message}`, {cause: err})\n    },\n  )\n}\n\ninterface CompareDependencyVersions {\n  pkg: string\n  installed: string\n  remote: string\n}\n\n/**\n * Compares the versions of dependencies in the studio or app with their remote versions.\n *\n * This function reads the package.json file in the provided working directory, and compares the versions of the dependencies\n * specified in the `autoUpdatesImports` parameter with their remote versions. If the versions do not match, the dependency is\n * added to a list of failed dependencies, which is returned by the function.\n *\n * The failed dependencies are anything that does not strictly match the remote version.\n * This means that if a version is lower or greater by even a patch it will be marked as failed.\n *\n * @param autoUpdatesImports - An object mapping package names to their remote import URLs.\n * @param workDir - The path to the working directory containing the package.json file.\n * @param fetchFn - Optional {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API | Fetch}-compatible function to use for requesting the current remote version of a module\n *\n * @returns A promise that resolves to an array of objects, each containing\n * the name of a package whose local and remote versions do not match, along with the local and remote versions.\n *\n * @throws Throws an error if the remote version of a package cannot be fetched, or if the local version of a package\n * cannot be parsed.\n */\nexport async function compareDependencyVersions(\n  packages: {version: string; name: string}[],\n  workDir: string,\n  {fetchFn = globalThis.fetch}: {appId?: string; fetchFn?: typeof fetch} = {},\n): Promise<Array<CompareDependencyVersions>> {\n  const manifest = await readPackageManifest(path.join(workDir, 'package.json'))\n  const dependencies = {...manifest.dependencies, ...manifest.devDependencies}\n\n  const failedDependencies: Array<CompareDependencyVersions> = []\n\n  for (const pkg of packages) {\n    const resolvedVersion = await getRemoteResolvedVersion(fetchFn, getModuleUrl(pkg))\n\n    const manifestPath = resolveFrom.silent(workDir, path.join(pkg.name, 'package.json'))\n\n    const manifestVersion = dependencies[pkg.name]\n\n    const installed = semver.coerce(\n      manifestPath\n        ? semver.parse((await readPackageManifest(manifestPath)).version)\n        : semver.coerce(manifestVersion),\n    )\n\n    if (!installed) {\n      throw new Error(`Failed to parse installed version for ${pkg}`)\n    }\n\n    if (!semver.eq(resolvedVersion, installed.version)) {\n      failedDependencies.push({\n        pkg: pkg.name,\n        installed: installed.version,\n        remote: resolvedVersion,\n      })\n    }\n  }\n\n  return failedDependencies\n}\n","import path from 'node:path'\n\nimport resolveFrom from 'resolve-from'\n\nimport {readPackageManifest} from './readPackageManifest'\n\n/**\n * Reads the version number of the _installed_ module, or returns `null` if not found\n *\n * @param dir - Path of the directory to read the module from\n * @param moduleName - Name of module to get installed version for\n * @returns Version number, of null\n */\nexport async function readModuleVersion(dir: string, moduleName: string): Promise<string | null> {\n  const manifestPath = resolveFrom.silent(dir, path.join(moduleName, 'package.json'))\n  return manifestPath ? (await readPackageManifest(manifestPath)).version : null\n}\n","import {type CliConfig} from '@sanity/cli'\nimport chalk from 'chalk'\n\ninterface AutoUpdateSources {\n  flags: {['auto-updates']?: boolean}\n  cliConfig?: CliConfig\n  output?: {warn: (message: string) => void}\n}\n\n/**\n * Compares parameters from various sources to determine whether or not to auto-update\n * @param sources - The sources of the auto-update parameter, including CLI flags and the CLI config\n * @returns boolean\n * @internal\n */\nexport function shouldAutoUpdate({flags, cliConfig, output}: AutoUpdateSources): boolean {\n  // cli flags (for example, '--no-auto-updates') should take precedence\n  if ('auto-updates' in flags) {\n    if (output) {\n      const flagUsed = flags['auto-updates'] ? '--auto-updates' : '--no-auto-updates'\n      output.warn(\n        chalk.yellow(\n          `The ${flagUsed} flag is deprecated for \\`deploy\\` and \\`build\\` commands. Set the \\`autoUpdates\\` option in \\`sanity.cli.ts\\` or \\`sanity.cli.js\\` instead.`,\n        ),\n      )\n    }\n    return Boolean(flags['auto-updates'])\n  }\n\n  const hasOldCliConfigFlag = cliConfig && 'autoUpdates' in cliConfig\n  const hasNewCliConfigFlag =\n    cliConfig &&\n    'deployment' in cliConfig &&\n    cliConfig.deployment &&\n    'autoUpdates' in cliConfig.deployment\n\n  if (hasOldCliConfigFlag && hasNewCliConfigFlag) {\n    throw new Error(\n      'Found both `autoUpdates` (deprecated) and `deployment.autoUpdates` in sanity.cli.js. Please remove the deprecated top level `autoUpdates` config.',\n    )\n  }\n  if (hasOldCliConfigFlag) {\n    output?.warn(\n      chalk.yellow(\n        `The \\`autoUpdates\\` config has moved to \\`deployment.autoUpdates\\`.\nPlease update \\`sanity.cli.ts\\` or \\`sanity.cli.js\\` and make the following change:\n${chalk.red(`-  autoUpdates: ${cliConfig.autoUpdates},`)}\n${chalk.green(`+  deployment: {autoUpdates: ${cliConfig.autoUpdates}}}`)}\n`,\n      ),\n    )\n  }\n  return Boolean(hasOldCliConfigFlag ? cliConfig.autoUpdates : cliConfig?.deployment?.autoUpdates)\n}\n","export const baseUrl =\n  process.env.SANITY_INTERNAL_ENV === 'staging' ? 'https://sanity.work' : 'https://sanity.io'\n","import path from 'node:path'\n\nimport {type CliOutputter} from '@sanity/cli'\nimport chalk from 'chalk'\nimport {warning} from 'log-symbols'\n\nimport {baseUrl} from './baseUrl'\n\nexport function warnAboutMissingAppId({\n  appType,\n  projectId,\n  output,\n  cliConfigPath,\n}: {\n  appType: 'studio' | 'app'\n  output: CliOutputter\n  projectId: string | undefined\n  cliConfigPath: string | undefined\n}) {\n  const manageUrl = `${baseUrl}/manage${projectId ? `/project/${projectId}/studios` : ''}`\n  const cliConfigFile = cliConfigPath ? path.basename(cliConfigPath) : 'sanity.cli.js'\n  output.print(\n    `${warning} No ${chalk.bold('appId')} configured. This ${appType} will auto-update to the ${chalk.green.bold('latest')} channel. To enable fine grained version selection, head over to ${chalk.cyan(manageUrl)} and add the appId to the ${chalk.bold('deployment')} section in ${chalk.bold(cliConfigFile)}.\n        `,\n  )\n}\n"],"names":["MODULES_HOST","process","env","SANITY_MODULES_HOST","SANITY_INTERNAL_ENV","currentUnixTime","Math","floor","Date","now","getAutoUpdatesImportMap","packages","options","Object","fromEntries","flatMap","pkg","getAppAutoUpdateImportMapForPackage","moduleUrl","getModuleUrl","name","timestamp","appId","getByAppModuleUrl","baseUrl","getLegacyModuleUrl","encodedMinVer","encodeURIComponent","version","rewriteScopedPackage","pkgName","includes","scope","split","join","isPackageManifest","item","readPackageJson","filePath","JSON","parse","readFile","err","Error","message","readPackageManifest","packageJsonPath","defaults","manifest","dependencies","devDependencies","getRemoteResolvedVersion","fetchFn","url","method","redirect","then","res","ok","status","resolved","headers","get","statusText","cause","compareDependencyVersions","workDir","globalThis","fetch","path","failedDependencies","resolvedVersion","manifestPath","resolveFrom","silent","manifestVersion","installed","semver","coerce","eq","push","remote","readModuleVersion","dir","moduleName","shouldAutoUpdate","flags","cliConfig","output","flagUsed","warn","chalk","yellow","Boolean","hasOldCliConfigFlag","hasNewCliConfigFlag","deployment","red","autoUpdates","green","warnAboutMissingAppId","appType","projectId","cliConfigPath","manageUrl","cliConfigFile","basename","print","warning","bold","cyan"],"mappings":"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"}