{"version":3,"file":"helpers.js","sources":["../../src/_internal/cli/actions/deploy/helpers.ts"],"sourcesContent":["import fs from 'node:fs/promises'\nimport path from 'node:path'\nimport {PassThrough} from 'node:stream'\nimport {type Gzip} from 'node:zlib'\n\nimport {type CliCommandContext, type CliOutputter} from '@sanity/cli'\nimport {type SanityClient} from '@sanity/client'\nimport FormData from 'form-data'\nimport {customAlphabet} from 'nanoid'\nimport readPkgUp from 'read-pkg-up'\n\nimport {debug as debugIt} from '../../debug'\nimport {determineIsApp} from '../../util/determineIsApp'\n\nexport const debug = debugIt.extend('deploy')\n\n// TODO: replace with `Promise.withResolvers()` once it lands in node\nfunction promiseWithResolvers<T>() {\n  let resolve!: (t: T) => void\n  let reject!: (err: unknown) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return {promise, resolve, reject}\n}\n\nexport interface ActiveDeployment {\n  deployedAt: string\n  deployedBy: string\n  isActiveDeployment: boolean\n  isAutoUpdating: boolean | null\n  size: string | null\n  createdAt: string\n  updatedAt: string\n  version: string\n}\n\nexport interface UserApplication {\n  id: string\n  projectId: string | null\n  organizationId: string | null\n  title: string | null\n  appHost: string\n  urlType: 'internal' | 'external'\n  createdAt: string\n  updatedAt: string\n  type: 'studio' | 'coreApp'\n  activeDeployment?: ActiveDeployment | null\n}\n\nexport interface GetUserApplicationsOptions {\n  client: SanityClient\n  organizationId?: string\n}\n\nexport interface GetUserApplicationOptions extends GetUserApplicationsOptions {\n  appHost?: string\n  appId?: string\n}\nexport async function getUserApplication({\n  client,\n  appHost,\n  appId,\n}: GetUserApplicationOptions): Promise<UserApplication | null> {\n  let query\n  let uri = '/user-applications'\n  if (appId) {\n    uri = `/user-applications/${appId}`\n  } else if (appHost) {\n    query = {appHost}\n  } else {\n    query = {default: 'true'}\n  }\n  try {\n    return await client.request({uri, query})\n  } catch (e) {\n    if (e?.statusCode === 404) {\n      return null\n    }\n\n    debug('Error getting user application', e)\n    throw e\n  }\n}\nexport async function getUserApplications({\n  client,\n  organizationId,\n}: GetUserApplicationsOptions): Promise<UserApplication[] | null> {\n  const query: Record<string, string> = organizationId\n    ? {organizationId: organizationId, appType: 'coreApp'}\n    : {appType: 'studio'}\n  try {\n    return await client.request({\n      uri: '/user-applications',\n      query,\n    })\n  } catch (e) {\n    if (e?.statusCode === 404) {\n      return null\n    }\n\n    debug('Error getting user applications', e)\n    throw e\n  }\n}\n\nfunction createUserApplication(\n  client: SanityClient,\n  body: Pick<UserApplication, 'appHost' | 'urlType' | 'type'> & {\n    title?: string\n  },\n  organizationId?: string,\n): Promise<UserApplication> {\n  const query: Record<string, string> = organizationId\n    ? {organizationId: organizationId, appType: 'coreApp'}\n    : {appType: 'studio'}\n  return client.request({uri: '/user-applications', method: 'POST', body, query})\n}\n\ninterface SelectApplicationOptions {\n  client: SanityClient\n  prompt: GetOrCreateUserApplicationOptions['context']['prompt']\n  message: string\n  createNewLabel: string\n  organizationId?: string\n}\n\n/**\n * Shared utility for selecting an existing application or opting to create a new one\n * @internal\n */\nasync function selectExistingApplication({\n  client,\n  prompt,\n  message,\n  createNewLabel,\n  organizationId,\n}: SelectApplicationOptions): Promise<UserApplication | null> {\n  const userApplications = await getUserApplications({client, organizationId})\n\n  if (!userApplications?.length) {\n    return null\n  }\n\n  const choices = userApplications.map((app) => ({\n    value: app.appHost,\n    name: app.title ?? app.appHost,\n  }))\n\n  const selected = await prompt.single({\n    message,\n    type: 'list',\n    choices: [...choices, new prompt.Separator(), {value: 'new', name: createNewLabel}],\n  })\n\n  if (selected === 'new') {\n    return null\n  }\n\n  return userApplications.find((app) => app.appHost === selected)!\n}\n\nexport interface GetOrCreateUserApplicationOptions {\n  client: SanityClient\n  context: Pick<CliCommandContext, 'output' | 'prompt' | 'cliConfig'>\n  spinner: ReturnType<CliOutputter['spinner']>\n}\n\n/**\n * These functions handle the logic for managing user applications when\n * studioHost is not provided in the CLI config.\n *\n * @internal\n *\n *    +-------------------------------+\n *    |   Fetch Existing user-app?   |\n *    +---------+--------------------+\n *              |\n *        +-----+-----+\n *        |           |\n *        v           v\n *   +---------+  +-------------------------+\n *   | Return  |  | Fetch all user apps     |\n *   | user-app|  +-------------------------+\n *   +---------+            |\n *                          v\n *           +---------------------------+\n *           |  User apps found?         |\n *           +-----------+---------------+\n *                       |\n *                +------v------+\n *                |             |\n *                v             v\n *   +--------------------+  +------------------------+\n *   | Show list and      |  | Prompt for hostname    |\n *   | prompt selection   |  | and create new app     |\n *   +--------------------+  +------------------------+\n */\nexport async function getOrCreateStudio({\n  client,\n  spinner,\n  context,\n}: GetOrCreateUserApplicationOptions): Promise<UserApplication> {\n  const {output, prompt} = context\n  // if there is already an existing user-app, then just return it\n  const existingUserApplication = await getUserApplication({client})\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  if (existingUserApplication) {\n    return existingUserApplication\n  }\n\n  const selectedApp = await selectExistingApplication({\n    client,\n    prompt,\n    message: 'Select existing studio hostname',\n    createNewLabel: 'Create new studio hostname',\n  })\n\n  if (selectedApp) {\n    return selectedApp\n  }\n\n  // otherwise, prompt the user for a hostname\n  output.print('Your project has not been assigned a studio hostname.')\n  output.print('To deploy your Sanity Studio to our hosted sanity.studio service,')\n  output.print('you will need one. Please enter the part you want to use.')\n\n  const {promise, resolve} = promiseWithResolvers<UserApplication>()\n\n  await prompt.single({\n    type: 'input',\n    filter: (inp: string) => inp.replace(/\\.sanity\\.studio$/i, ''),\n    message: 'Studio hostname (<value>.sanity.studio):',\n    // if a string is returned here, it is relayed to the user and prompt allows\n    // the user to try again until this function returns true\n    validate: async (appHost: string) => {\n      try {\n        const response = await createUserApplication(client, {\n          appHost,\n          urlType: 'internal',\n          type: 'studio',\n        })\n        resolve(response)\n        return true\n      } catch (e) {\n        // if the name is taken, it should return a 409 so we relay to the user\n        if ([402, 409].includes(e?.statusCode)) {\n          return e?.response?.body?.message || 'Bad request' // just in case\n        }\n\n        debug('Error creating user application', e)\n        // otherwise, it's a fatal error\n        throw e\n      }\n    },\n  })\n\n  return await promise\n}\n\n/**\n * Creates a core application with an auto-generated hostname\n *\n * @internal\n */\nexport async function getOrCreateApplication({\n  client,\n  context,\n  spinner,\n}: GetOrCreateUserApplicationOptions): Promise<UserApplication> {\n  const {prompt, cliConfig} = context\n  const organizationId = cliConfig && 'app' in cliConfig && cliConfig.app?.organizationId\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  const selectedApp = await selectExistingApplication({\n    client,\n    prompt,\n    message: 'Select an existing deployed application',\n    createNewLabel: 'Create new deployed application',\n    organizationId: organizationId || undefined,\n  })\n\n  if (selectedApp) {\n    return selectedApp\n  }\n\n  // First get the title from the user\n  const title = await prompt.single({\n    type: 'input',\n    message: 'Enter a title for your application:',\n    validate: (input: string) => input.length > 0 || 'Title is required',\n  })\n\n  const {promise, resolve, reject} = promiseWithResolvers<UserApplication>()\n\n  // Try to create the application, retrying with new hostnames if needed\n  const tryCreateApp = async () => {\n    // appHosts have some restrictions (no uppercase, must start with a letter)\n    const generateId = () => {\n      const letters = 'abcdefghijklmnopqrstuvwxyz'\n      const firstChar = customAlphabet(letters, 1)()\n      const rest = customAlphabet('abcdefghijklmnopqrstuvwxyz0123456789', 11)()\n      return `${firstChar}${rest}`\n    }\n\n    // we will likely prepend this with an org ID or other parameter in the future\n    const appHost = generateId()\n\n    try {\n      const response = await createUserApplication(\n        client,\n        {\n          appHost,\n          urlType: 'internal',\n          title,\n          type: 'coreApp',\n        },\n        organizationId || undefined,\n      )\n      resolve(response)\n      return true\n    } catch (e) {\n      // if the name is taken, generate a new one and try again\n      if ([402, 409].includes(e?.statusCode)) {\n        debug('App host taken, retrying with new host')\n        return tryCreateApp()\n      }\n\n      debug('Error creating core application', e)\n      reject(e)\n      // otherwise, it's a fatal error\n      throw e\n    }\n  }\n\n  spinner.start('Creating application')\n\n  await tryCreateApp()\n  const response = await promise\n\n  spinner.succeed()\n  return response\n}\n\nexport interface BaseConfigOptions {\n  client: SanityClient\n  context: Pick<CliCommandContext, 'output' | 'prompt' | 'cliConfig'>\n  spinner: ReturnType<CliOutputter['spinner']>\n}\n\ntype UserApplicationConfigOptions = BaseConfigOptions &\n  (\n    | {\n        /**\n         * @deprecated – appHost is replaced by appId, but kept for backwards compat\n         */\n        appHost: string | undefined\n        appId: undefined\n      }\n    | {\n        appId: string | undefined\n        /**\n         * @deprecated – appHost is replaced by appId, but kept for backwards compat\n         */\n        appHost: undefined\n      }\n  )\n\nasync function getOrCreateStudioFromConfig({\n  client,\n  context,\n  spinner,\n  appHost,\n  appId,\n}: UserApplicationConfigOptions): Promise<UserApplication> {\n  const {output} = context\n  // if there is already an existing user-app, then just return it\n  const existingUserApplication = await getUserApplication({client, appId, appHost})\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  if (existingUserApplication) {\n    return existingUserApplication\n  }\n\n  if (!appHost) {\n    throw new Error(`Application not found. Application with id ${appId} does not exist`)\n  }\n\n  output.print('Your project has not been assigned a studio hostname.')\n  output.print(`Creating https://${appHost}.sanity.studio`)\n  output.print('')\n  spinner.start('Creating studio hostname')\n\n  try {\n    const response = await createUserApplication(client, {\n      appHost,\n      urlType: 'internal',\n      type: 'studio',\n    })\n    spinner.succeed()\n    return response\n  } catch (e) {\n    spinner.fail()\n    // if the name is taken, it should return a 409 so we relay to the user\n    if ([402, 409].includes(e?.statusCode)) {\n      throw new Error(e?.response?.body?.message || 'Bad request') // just in case\n    }\n    debug('Error creating user application from config', e)\n    // otherwise, it's a fatal error\n    throw e\n  }\n}\n\nasync function getOrCreateAppFromConfig({\n  client,\n  context,\n  spinner,\n  appHost,\n  appId,\n}: UserApplicationConfigOptions): Promise<UserApplication> {\n  const {output, cliConfig} = context\n  const organizationId = cliConfig && 'app' in cliConfig && cliConfig.app?.organizationId\n  if (appId) {\n    const existingUserApplication = await getUserApplication({\n      client,\n      appId,\n      appHost,\n      organizationId: organizationId || undefined,\n    })\n    spinner.succeed()\n\n    if (existingUserApplication) {\n      return existingUserApplication\n    }\n  }\n\n  // custom apps cannot arbitrarily create ids or hosts, so send them to create option\n  output.print('The id provided in your configuration is not recognized.')\n  output.print('Checking existing applications...')\n  return getOrCreateApplication({client, context, spinner})\n}\n\n/**\n * This function handles the logic for managing user applications when\n * studioHost or appId is provided in the CLI config.\n *\n * @internal\n */\nexport async function getOrCreateUserApplicationFromConfig(\n  options: UserApplicationConfigOptions,\n): Promise<UserApplication> {\n  const {context, appId, appHost} = options\n  const isApp = determineIsApp(context.cliConfig)\n\n  if (isApp) {\n    return getOrCreateAppFromConfig(options)\n  }\n\n  if (!appId && !appHost) {\n    throw new Error(\n      'Studio was detected, but neither appId or appHost (deprecated) found in CLI config',\n    )\n  }\n\n  return getOrCreateStudioFromConfig(options)\n}\n\nexport interface CreateDeploymentOptions {\n  client: SanityClient\n  applicationId: string\n  version: string\n  isAutoUpdating: boolean\n  tarball: Gzip\n  isApp?: boolean\n}\n\nexport async function createDeployment({\n  client,\n  tarball,\n  applicationId,\n  isAutoUpdating,\n  version,\n  isApp,\n}: CreateDeploymentOptions): Promise<{location: string}> {\n  const formData = new FormData()\n  formData.append('isAutoUpdating', isAutoUpdating.toString())\n  formData.append('version', version)\n  formData.append('tarball', tarball, {contentType: 'application/gzip', filename: 'app.tar.gz'})\n\n  return client.request({\n    uri: `/user-applications/${applicationId}/deployments`,\n    method: 'POST',\n    headers: formData.getHeaders(),\n    body: formData.pipe(new PassThrough()),\n    query: isApp ? {appType: 'coreApp'} : {appType: 'studio'},\n  })\n}\n\nexport interface DeleteUserApplicationOptions {\n  client: SanityClient\n  applicationId: string\n  appType: 'coreApp' | 'studio'\n}\n\nexport async function deleteUserApplication({\n  applicationId,\n  client,\n  appType,\n}: DeleteUserApplicationOptions): Promise<void> {\n  await client.request({\n    uri: `/user-applications/${applicationId}`,\n    query: {\n      appType,\n    },\n    method: 'DELETE',\n  })\n}\n\nexport async function getInstalledSanityVersion(): Promise<string> {\n  const sanityPkgPath = (await readPkgUp({cwd: __dirname}))?.path\n  if (!sanityPkgPath) {\n    throw new Error('Unable to resolve `sanity` module root')\n  }\n\n  const pkg = JSON.parse(await fs.readFile(sanityPkgPath, 'utf-8'))\n  if (typeof pkg?.version !== 'string') {\n    throw new Error('Unable to find version of `sanity` module')\n  }\n  return pkg.version\n}\n\nexport async function dirIsEmptyOrNonExistent(sourceDir: string): Promise<boolean> {\n  try {\n    const stats = await fs.stat(sourceDir)\n    if (!stats.isDirectory()) {\n      throw new Error(`Directory ${sourceDir} is not a directory`)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return true\n    }\n\n    throw err\n  }\n\n  const content = await fs.readdir(sourceDir)\n  return content.length === 0\n}\n\nexport async function checkDir(sourceDir: string): Promise<void> {\n  try {\n    const stats = await fs.stat(sourceDir)\n    if (!stats.isDirectory()) {\n      throw new Error(`Directory ${sourceDir} is not a directory`)\n    }\n  } catch (err) {\n    const error = err.code === 'ENOENT' ? new Error(`Directory \"${sourceDir}\" does not exist`) : err\n\n    throw error\n  }\n\n  try {\n    await fs.stat(path.join(sourceDir, 'index.html'))\n  } catch (err) {\n    const error =\n      err.code === 'ENOENT'\n        ? new Error(\n            [\n              `\"${sourceDir}/index.html\" does not exist -`,\n              '[SOURCE_DIR] must be a directory containing',\n              'a Sanity studio built using \"sanity build\"',\n            ].join(' '),\n          )\n        : err\n\n    throw error\n  }\n}\n"],"names":["debug","debugIt","extend","promiseWithResolvers","resolve","reject","promise","Promise","res","rej","getUserApplication","client","appHost","appId","query","uri","default","request","e","statusCode","getUserApplications","organizationId","appType","createUserApplication","body","method","selectExistingApplication","prompt","message","createNewLabel","userApplications","length","choices","map","app","value","name","title","selected","single","type","Separator","find","getOrCreateStudio","spinner","context","output","existingUserApplication","succeed","selectedApp","print","filter","inp","replace","validate","response","urlType","includes","getOrCreateApplication","cliConfig","undefined","input","tryCreateApp","generateId","firstChar","customAlphabet","rest","start","getOrCreateStudioFromConfig","Error","fail","getOrCreateAppFromConfig","getOrCreateUserApplicationFromConfig","options","determineIsApp","createDeployment","tarball","applicationId","isAutoUpdating","version","isApp","formData","FormData","append","toString","contentType","filename","headers","getHeaders","pipe","PassThrough","deleteUserApplication","getInstalledSanityVersion","sanityPkgPath","readPkgUp","cwd","__dirname","path","pkg","JSON","parse","fs","readFile","dirIsEmptyOrNonExistent","sourceDir","stat","isDirectory","err","code","readdir","checkDir","join"],"mappings":"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"}