"use strict";
var path = require("node:path"), resolveFrom = require("resolve-from"), semver = require("semver"), fs = require("node:fs/promises"), chalk = require("chalk");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var path__default = /* @__PURE__ */ _interopDefaultCompat(path), resolveFrom__default = /* @__PURE__ */ _interopDefaultCompat(resolveFrom), semver__default = /* @__PURE__ */ _interopDefaultCompat(semver), chalk__default = /* @__PURE__ */ _interopDefaultCompat(chalk);
const MODULES_HOST = process.env.SANITY_MODULES_HOST || (process.env.SANITY_INTERNAL_ENV === "staging" ? "https://sanity-cdn.work" : "https://sanity-cdn.com");
function currentUnixTime() {
  return Math.floor(Date.now() / 1e3);
}
function getAutoUpdatesImportMap(packages, options = {}) {
  return Object.fromEntries(packages.flatMap((pkg) => getAppAutoUpdateImportMapForPackage(pkg, options)));
}
function getAppAutoUpdateImportMapForPackage(pkg, options = {}) {
  const moduleUrl = getModuleUrl(pkg, options);
  return [[pkg.name, moduleUrl], [`${pkg.name}/`, `${moduleUrl}/`]];
}
function getModuleUrl(pkg, options = {}) {
  const {
    timestamp = currentUnixTime()
  } = options, encodedMinVer = encodeURIComponent(`^${pkg.version}`);
  return `${options.baseUrl || MODULES_HOST}/v1/modules/${rewriteScopedPackage(pkg.name)}/default/${encodedMinVer}/t${timestamp}`;
}
function rewriteScopedPackage(pkgName) {
  if (!pkgName.includes("@"))
    return pkgName;
  const [scope, ...pkg] = pkgName.split("/");
  return `${scope}__${pkg.join("")}`;
}
function isPackageManifest(item) {
  return typeof item == "object" && item !== null && "name" in item && "version" in item;
}
async function readPackageJson(filePath) {
  try {
    return JSON.parse(await fs.readFile(filePath, "utf8"));
  } catch (err) {
    throw new Error(`Failed to read "${filePath}": ${err.message}`);
  }
}
async function readPackageManifest(packageJsonPath, defaults = {}) {
  let manifest;
  try {
    manifest = {
      ...defaults,
      ...await readPackageJson(packageJsonPath)
    };
  } catch (err) {
    throw new Error(`Failed to read "${packageJsonPath}": ${err.message}`);
  }
  if (!isPackageManifest(manifest))
    throw new Error(`Failed to read "${packageJsonPath}": Invalid package manifest`);
  const {
    name,
    version,
    dependencies = {},
    devDependencies = {}
  } = manifest;
  return {
    name,
    version,
    dependencies,
    devDependencies
  };
}
function getRemoteResolvedVersion(fetchFn, url) {
  return fetchFn(url, {
    method: "HEAD",
    redirect: "manual"
  }).then((res) => {
    if (res.ok || res.status < 400) {
      const resolved = res.headers.get("x-resolved-version");
      if (!resolved)
        throw new Error(`Missing 'x-resolved-version' header on response from HEAD ${url}`);
      return resolved;
    }
    throw new Error(`Unexpected HTTP response: ${res.status} ${res.statusText}`);
  }, (err) => {
    throw new Error(`Failed to fetch remote version for ${url}: ${err.message}`, {
      cause: err
    });
  });
}
async function compareDependencyVersions(packages, workDir, {
  fetchFn = globalThis.fetch
} = {}) {
  const manifest = await readPackageManifest(path__default.default.join(workDir, "package.json")), dependencies = {
    ...manifest.dependencies,
    ...manifest.devDependencies
  }, failedDependencies = [];
  for (const pkg of packages) {
    const resolvedVersion = await getRemoteResolvedVersion(fetchFn, getModuleUrl(pkg)), manifestPath = resolveFrom__default.default.silent(workDir, path__default.default.join(pkg.name, "package.json")), manifestVersion = dependencies[pkg.name], installed = semver__default.default.coerce(manifestPath ? semver__default.default.parse((await readPackageManifest(manifestPath)).version) : semver__default.default.coerce(manifestVersion));
    if (!installed)
      throw new Error(`Failed to parse installed version for ${pkg}`);
    semver__default.default.eq(resolvedVersion, installed.version) || failedDependencies.push({
      pkg: pkg.name,
      installed: installed.version,
      remote: resolvedVersion
    });
  }
  return failedDependencies;
}
async function readModuleVersion(dir, moduleName) {
  const manifestPath = resolveFrom__default.default.silent(dir, path__default.default.join(moduleName, "package.json"));
  return manifestPath ? (await readPackageManifest(manifestPath)).version : null;
}
function shouldAutoUpdate({
  flags,
  cliConfig,
  output
}) {
  if ("auto-updates" in flags) {
    if (output) {
      const flagUsed = flags["auto-updates"] ? "--auto-updates" : "--no-auto-updates";
      output.warn(chalk__default.default.yellow(`The ${flagUsed} flag is deprecated for \`deploy\` and \`build\` commands. Set the \`autoUpdates\` option in \`sanity.cli.ts\` or \`sanity.cli.js\` instead.`));
    }
    return !!flags["auto-updates"];
  }
  return cliConfig && "autoUpdates" in cliConfig ? !!cliConfig.autoUpdates : !1;
}
exports.compareDependencyVersions = compareDependencyVersions;
exports.getAutoUpdatesImportMap = getAutoUpdatesImportMap;
exports.readModuleVersion = readModuleVersion;
exports.readPackageJson = readPackageJson;
exports.readPackageManifest = readPackageManifest;
exports.shouldAutoUpdate = shouldAutoUpdate;
//# sourceMappingURL=shouldAutoUpdate.js.map
