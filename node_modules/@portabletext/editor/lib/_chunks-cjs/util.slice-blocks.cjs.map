{"version":3,"file":"util.slice-blocks.cjs","sources":["../../src/utils/util.is-keyed-segment.ts","../../src/selection/selection-point.ts","../../src/utils/util.block-offset.ts","../../src/utils/util.get-block-start-point.ts","../../src/utils/util.get-selection-end-point.ts","../../src/utils/util.get-selection-start-point.ts","../../src/utils/util.get-text-block-text.ts","../../src/internal-utils/asserters.ts","../../src/internal-utils/parse-blocks.ts","../../src/editor/key-generator.ts","../../src/utils/util.slice-blocks.ts"],"sourcesContent":["import type {KeyedSegment} from '@sanity/types'\n\n/**\n * @public\n */\nexport function isKeyedSegment(segment: unknown): segment is KeyedSegment {\n  return typeof segment === 'object' && segment !== null && '_key' in segment\n}\n","import type {EditorSelectionPoint} from '../types/editor'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\n\nexport function getBlockKeyFromSelectionPoint(point: EditorSelectionPoint) {\n  const blockPathSegment = point.path.at(0)\n\n  if (isKeyedSegment(blockPathSegment)) {\n    return blockPathSegment._key\n  }\n\n  return undefined\n}\n\nexport function getChildKeyFromSelectionPoint(point: EditorSelectionPoint) {\n  const childPathSegment = point.path.at(2)\n\n  if (isKeyedSegment(childPathSegment)) {\n    return childPathSegment._key\n  }\n\n  return undefined\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../selection/selection-point'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport type {ChildPath} from '../types/paths'\n\n/**\n * @public\n */\nexport function blockOffsetToSpanSelectionPoint({\n  context,\n  blockOffset,\n  direction,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  blockOffset: BlockOffset\n  direction: 'forward' | 'backward'\n}) {\n  let offsetLeft = blockOffset.offset\n  let selectionPoint: {path: ChildPath; offset: number} | undefined\n  let skippedInlineObject = false\n\n  for (const block of context.value) {\n    if (block._key !== blockOffset.path[0]._key) {\n      continue\n    }\n\n    if (!isTextBlock(context, block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (direction === 'forward') {\n        if (!isSpan(context, child)) {\n          continue\n        }\n\n        if (offsetLeft <= child.text.length) {\n          selectionPoint = {\n            path: [...blockOffset.path, 'children', {_key: child._key}],\n            offset: offsetLeft,\n          }\n          break\n        }\n\n        offsetLeft -= child.text.length\n\n        continue\n      }\n\n      if (!isSpan(context, child)) {\n        skippedInlineObject = true\n        continue\n      }\n\n      if (offsetLeft === 0 && selectionPoint && !skippedInlineObject) {\n        if (skippedInlineObject) {\n          selectionPoint = {\n            path: [...blockOffset.path, 'children', {_key: child._key}],\n            offset: 0,\n          }\n        }\n        break\n      }\n\n      if (offsetLeft > child.text.length) {\n        offsetLeft -= child.text.length\n        continue\n      }\n\n      if (offsetLeft <= child.text.length) {\n        selectionPoint = {\n          path: [...blockOffset.path, 'children', {_key: child._key}],\n          offset: offsetLeft,\n        }\n\n        offsetLeft -= child.text.length\n\n        if (offsetLeft !== 0) {\n          break\n        }\n      }\n    }\n  }\n\n  return selectionPoint\n}\n\n/**\n * @public\n */\nexport function spanSelectionPointToBlockOffset({\n  context,\n  selectionPoint,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  let offset = 0\n\n  const blockKey = getBlockKeyFromSelectionPoint(selectionPoint)\n  const spanKey = getChildKeyFromSelectionPoint(selectionPoint)\n\n  if (!blockKey || !spanKey) {\n    return undefined\n  }\n\n  for (const block of context.value) {\n    if (block._key !== blockKey) {\n      continue\n    }\n\n    if (!isTextBlock(context, block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (!isSpan(context, child)) {\n        continue\n      }\n\n      if (child._key === spanKey) {\n        return {\n          path: [{_key: block._key}],\n          offset: offset + selectionPoint.offset,\n        }\n      }\n\n      offset += child.text.length\n    }\n  }\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {PortableTextBlock} from '@sanity/types'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport type {BlockPath} from '../types/paths'\n\n/**\n * @public\n */\nexport function getBlockStartPoint({\n  context,\n  block,\n}: {\n  context: Pick<EditorContext, 'schema'>\n  block: {\n    node: PortableTextBlock\n    path: BlockPath\n  }\n}): EditorSelectionPoint {\n  if (isTextBlock(context, block.node)) {\n    return {\n      path: [...block.path, 'children', {_key: block.node.children[0]._key}],\n      offset: 0,\n    }\n  }\n\n  return {\n    path: block.path,\n    offset: 0,\n  }\n}\n","import type {EditorSelection, EditorSelectionPoint} from '..'\n\n/**\n * @public\n */\nexport function getSelectionEndPoint<\n  TEditorSelection extends NonNullable<EditorSelection> | null,\n  TEditorSelectionPoint extends\n    EditorSelectionPoint | null = TEditorSelection extends NonNullable<EditorSelection>\n    ? EditorSelectionPoint\n    : null,\n>(selection: TEditorSelection): TEditorSelectionPoint {\n  if (!selection) {\n    return null as TEditorSelectionPoint\n  }\n\n  return (\n    selection.backward ? selection.anchor : selection.focus\n  ) as TEditorSelectionPoint\n}\n","import type {EditorSelection, EditorSelectionPoint} from '..'\n\n/**\n * @public\n */\nexport function getSelectionStartPoint<\n  TEditorSelection extends NonNullable<EditorSelection> | null,\n  TEditorSelectionPoint extends\n    EditorSelectionPoint | null = TEditorSelection extends NonNullable<EditorSelection>\n    ? EditorSelectionPoint\n    : null,\n>(selection: TEditorSelection): TEditorSelectionPoint {\n  if (!selection) {\n    return null as TEditorSelectionPoint\n  }\n\n  return (\n    selection.backward ? selection.focus : selection.anchor\n  ) as TEditorSelectionPoint\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\n\n/**\n * @public\n */\nexport function getTextBlockText(block: PortableTextTextBlock) {\n  return block.children.map((child) => child.text ?? '').join('')\n}\n","import type {TypedObject} from '@sanity/types'\n\nexport function isTypedObject(object: unknown): object is TypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {\n  PortableTextBlock,\n  PortableTextListBlock,\n  PortableTextObject,\n  PortableTextSpan,\n  PortableTextTextBlock,\n  TypedObject,\n} from '@sanity/types'\nimport type {EditorSchema} from '../editor/editor-schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {isTypedObject} from './asserters'\n\nexport function parseBlocks({\n  context,\n  blocks,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  blocks: unknown\n  options: {\n    removeUnusedMarkDefs: boolean\n    validateFields: boolean\n  }\n}): Array<PortableTextBlock> {\n  if (!Array.isArray(blocks)) {\n    return []\n  }\n\n  return blocks.flatMap((block) => {\n    const parsedBlock = parseBlock({context, block, options})\n\n    return parsedBlock ? [parsedBlock] : []\n  })\n}\n\nexport function parseBlock({\n  context,\n  block,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  block: unknown\n  options: {\n    removeUnusedMarkDefs: boolean\n    validateFields: boolean\n  }\n}): PortableTextBlock | undefined {\n  return (\n    parseTextBlock({block, context, options}) ??\n    parseBlockObject({blockObject: block, context, options})\n  )\n}\n\nexport function parseBlockObject({\n  blockObject,\n  context,\n  options,\n}: {\n  blockObject: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {validateFields: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(blockObject)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.blockObjects.find(\n    ({name}) => name === blockObject._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: blockObject,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nexport function isListBlock(\n  context: Pick<EditorContext, 'schema'>,\n  block: unknown,\n): block is PortableTextListBlock {\n  return (\n    isTextBlock(context, block) &&\n    block.level !== undefined &&\n    block.listItem !== undefined\n  )\n}\n\nexport function parseTextBlock({\n  block,\n  context,\n  options,\n}: {\n  block: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {\n    removeUnusedMarkDefs: boolean\n    validateFields: boolean\n  }\n}): PortableTextTextBlock | undefined {\n  if (!isTypedObject(block)) {\n    return undefined\n  }\n\n  const customFields: Record<string, unknown> = {}\n\n  for (const key of Object.keys(block)) {\n    if (\n      key === '_type' ||\n      key === '_key' ||\n      key === 'children' ||\n      key === 'markDefs' ||\n      key === 'style' ||\n      key === 'listItem' ||\n      key === 'level'\n    ) {\n      continue\n    }\n\n    if (options.validateFields) {\n      if (context.schema.block.fields?.some((field) => field.name === key)) {\n        customFields[key] = block[key]\n      }\n    } else {\n      customFields[key] = block[key]\n    }\n  }\n\n  if (block._type !== context.schema.block.name) {\n    return undefined\n  }\n\n  const _key =\n    typeof block._key === 'string' ? block._key : context.keyGenerator()\n\n  const unparsedMarkDefs: Array<unknown> = Array.isArray(block.markDefs)\n    ? block.markDefs\n    : []\n  const markDefKeyMap = new Map<string, string>()\n  const markDefs = unparsedMarkDefs.flatMap((markDef) => {\n    if (!isTypedObject(markDef)) {\n      return []\n    }\n\n    const schemaType = context.schema.annotations.find(\n      ({name}) => name === markDef._type,\n    )\n\n    if (!schemaType) {\n      return []\n    }\n\n    if (typeof markDef._key !== 'string') {\n      // If the `markDef` doesn't have a `_key` then we don't know what spans\n      // it belongs to and therefore we have to discard it.\n      return []\n    }\n\n    const parsedAnnotation = parseObject({\n      object: markDef,\n      context: {\n        schemaType,\n        keyGenerator: context.keyGenerator,\n      },\n      options,\n    })\n\n    if (!parsedAnnotation) {\n      return []\n    }\n\n    markDefKeyMap.set(markDef._key, parsedAnnotation._key)\n\n    return [parsedAnnotation]\n  })\n\n  const unparsedChildren: Array<unknown> = Array.isArray(block.children)\n    ? block.children\n    : []\n\n  const children = unparsedChildren\n    .map(\n      (child) =>\n        parseSpan({span: child, context, markDefKeyMap, options}) ??\n        parseInlineObject({inlineObject: child, context, options}),\n    )\n    .filter((child) => child !== undefined)\n  const marks = children.flatMap((child) => child.marks ?? [])\n\n  const parsedBlock: PortableTextTextBlock = {\n    _type: context.schema.block.name,\n    _key,\n    children:\n      children.length > 0\n        ? children\n        : [\n            {\n              _key: context.keyGenerator(),\n              _type: context.schema.span.name,\n              text: '',\n              marks: [],\n            },\n          ],\n    markDefs: options.removeUnusedMarkDefs\n      ? markDefs.filter((markDef) => marks.includes(markDef._key))\n      : markDefs,\n    ...customFields,\n  }\n\n  if (\n    typeof block.style === 'string' &&\n    context.schema.styles.find((style) => style.name === block.style)\n  ) {\n    parsedBlock.style = block.style\n  } else {\n    const defaultStyle = context.schema.styles.at(0)?.name\n\n    if (defaultStyle !== undefined) {\n      parsedBlock.style = defaultStyle\n    } else {\n      console.error('Expected default style')\n    }\n  }\n\n  if (\n    typeof block.listItem === 'string' &&\n    context.schema.lists.find((list) => list.name === block.listItem)\n  ) {\n    parsedBlock.listItem = block.listItem\n  }\n\n  if (typeof block.level === 'number') {\n    parsedBlock.level = block.level\n  }\n\n  return parsedBlock\n}\n\nexport function parseSpan({\n  span,\n  context,\n  markDefKeyMap,\n  options,\n}: {\n  span: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  markDefKeyMap: Map<string, string>\n  options: {validateFields: boolean}\n}): PortableTextSpan | undefined {\n  if (!isTypedObject(span)) {\n    return undefined\n  }\n\n  const customFields: Record<string, unknown> = {}\n\n  for (const key of Object.keys(span)) {\n    if (\n      key !== '_type' &&\n      key !== '_key' &&\n      key !== 'text' &&\n      key !== 'marks'\n    ) {\n      customFields[key] = span[key]\n    }\n  }\n\n  // In reality, the span schema name is always 'span', but we only the check here anyway\n  if (span._type !== context.schema.span.name || span._type !== 'span') {\n    return undefined\n  }\n\n  const unparsedMarks: Array<unknown> = Array.isArray(span.marks)\n    ? span.marks\n    : []\n  const marks = unparsedMarks.flatMap((mark) => {\n    if (typeof mark !== 'string') {\n      return []\n    }\n\n    const markDefKey = markDefKeyMap.get(mark)\n\n    if (markDefKey !== undefined) {\n      return [markDefKey]\n    }\n\n    if (\n      context.schema.decorators.some((decorator) => decorator.name === mark)\n    ) {\n      return [mark]\n    }\n\n    return []\n  })\n\n  return {\n    _type: 'span',\n    _key: typeof span._key === 'string' ? span._key : context.keyGenerator(),\n    text: typeof span.text === 'string' ? span.text : '',\n    marks,\n    ...(options.validateFields ? {} : customFields),\n  }\n}\n\nexport function parseInlineObject({\n  inlineObject,\n  context,\n  options,\n}: {\n  inlineObject: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {validateFields: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(inlineObject)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.inlineObjects.find(\n    ({name}) => name === inlineObject._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: inlineObject,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nexport function parseAnnotation({\n  annotation,\n  context,\n  options,\n}: {\n  annotation: TypedObject\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {validateFields: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(annotation)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.annotations.find(\n    ({name}) => name === annotation._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: annotation,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nfunction parseObject({\n  object,\n  context,\n  options,\n}: {\n  object: TypedObject\n  context: Pick<EditorContext, 'keyGenerator'> & {\n    schemaType: EditorSchema['blockObjects'][0]\n  }\n  options: {validateFields: boolean}\n}): PortableTextObject {\n  const {_type, _key, ...customFields} = object\n\n  // Validates all props on the object and only takes those that match\n  // the name of a field\n  const values = options.validateFields\n    ? context.schemaType.fields.reduce<Record<string, unknown>>(\n        (fieldValues, field) => {\n          const fieldValue = object[field.name]\n\n          if (fieldValue !== undefined) {\n            fieldValues[field.name] = fieldValue\n          }\n\n          return fieldValues\n        },\n        {},\n      )\n    : customFields\n\n  return {\n    _type: context.schemaType.name,\n    _key:\n      typeof object._key === 'string' ? object._key : context.keyGenerator(),\n    ...values,\n  }\n}\n","import getRandomValues from 'get-random-values-esm'\n\n/**\n * @public\n */\nexport const defaultKeyGenerator = (): string => randomKey(12)\n\nconst getByteHexTable = (() => {\n  let table: any[]\n  return () => {\n    if (table) {\n      return table\n    }\n\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  getRandomValues(rnds8)\n  return rnds8\n}\n\nfunction randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {PortableTextBlock} from '@sanity/types'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {defaultKeyGenerator} from '../editor/key-generator'\nimport {parseBlock} from '../internal-utils/parse-blocks'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../selection/selection-point'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\n\n/**\n * @public\n */\nexport function sliceBlocks({\n  context,\n  blocks,\n}: {\n  context: Pick<EditorContext, 'schema' | 'selection'>\n  blocks: Array<PortableTextBlock>\n}): Array<PortableTextBlock> {\n  const slice: Array<PortableTextBlock> = []\n\n  if (!context.selection) {\n    return slice\n  }\n\n  let startBlock: PortableTextBlock | undefined\n  const middleBlocks: PortableTextBlock[] = []\n  let endBlock: PortableTextBlock | undefined\n\n  const startPoint = getSelectionStartPoint(context.selection)\n  const endPoint = getSelectionEndPoint(context.selection)\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n  const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return slice\n  }\n\n  for (const block of blocks) {\n    if (!isTextBlock(context, block)) {\n      if (block._key === startBlockKey && block._key === endBlockKey) {\n        startBlock = block\n        break\n      }\n    }\n\n    if (block._key === startBlockKey) {\n      if (!isTextBlock(context, block)) {\n        startBlock = block\n        continue\n      }\n\n      if (startChildKey) {\n        for (const child of block.children) {\n          if (child._key === startChildKey) {\n            if (isSpan(context, child)) {\n              const text =\n                child._key === endChildKey\n                  ? child.text.slice(startPoint.offset, endPoint.offset)\n                  : child.text.slice(startPoint.offset)\n\n              startBlock = {\n                ...block,\n                children: [\n                  {\n                    ...child,\n                    text,\n                  },\n                ],\n              }\n            } else {\n              startBlock = {\n                ...block,\n                children: [child],\n              }\n            }\n\n            if (startChildKey === endChildKey) {\n              break\n            }\n            continue\n          }\n\n          if (startBlock && isTextBlock(context, startBlock)) {\n            if (\n              endChildKey &&\n              child._key === endChildKey &&\n              isSpan(context, child)\n            ) {\n              startBlock.children.push({\n                ...child,\n                text: child.text.slice(0, endPoint.offset),\n              })\n            } else {\n              startBlock.children.push(child)\n            }\n\n            if (\n              block._key === endBlockKey &&\n              endChildKey &&\n              child._key === endChildKey\n            ) {\n              break\n            }\n          }\n        }\n\n        if (startBlockKey === endBlockKey) {\n          break\n        }\n\n        continue\n      }\n\n      startBlock = block\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n    }\n\n    if (block._key === endBlockKey) {\n      if (!isTextBlock(context, block)) {\n        endBlock = block\n        break\n      }\n\n      if (endChildKey) {\n        endBlock = {\n          ...block,\n          children: [],\n        }\n\n        for (const child of block.children) {\n          if (endBlock && isTextBlock(context, endBlock)) {\n            if (child._key === endChildKey && isSpan(context, child)) {\n              endBlock.children.push({\n                ...child,\n                text: child.text.slice(0, endPoint.offset),\n              })\n\n              break\n            }\n\n            endBlock.children.push(child)\n\n            if (endChildKey && child._key === endChildKey) {\n              break\n            }\n          }\n        }\n\n        break\n      }\n\n      endBlock = block\n\n      break\n    }\n\n    if (startBlock) {\n      middleBlocks.push(\n        parseBlock({\n          context: {\n            ...context,\n            keyGenerator: defaultKeyGenerator,\n          },\n          block,\n          options: {removeUnusedMarkDefs: true, validateFields: false},\n        }) ?? block,\n      )\n    }\n  }\n\n  const parsedStartBlock = startBlock\n    ? parseBlock({\n        context: {\n          ...context,\n          keyGenerator: defaultKeyGenerator,\n        },\n        block: startBlock,\n        options: {removeUnusedMarkDefs: true, validateFields: false},\n      })\n    : undefined\n\n  const parsedEndBlock = endBlock\n    ? parseBlock({\n        context: {\n          ...context,\n          keyGenerator: defaultKeyGenerator,\n        },\n        block: endBlock,\n        options: {removeUnusedMarkDefs: true, validateFields: false},\n      })\n    : undefined\n\n  return [\n    ...(parsedStartBlock ? [parsedStartBlock] : []),\n    ...middleBlocks,\n    ...(parsedEndBlock ? [parsedEndBlock] : []),\n  ]\n}\n"],"names":["isKeyedSegment","segment","getBlockKeyFromSelectionPoint","point","blockPathSegment","path","at","_key","getChildKeyFromSelectionPoint","childPathSegment","blockOffsetToSpanSelectionPoint","context","blockOffset","direction","offsetLeft","offset","selectionPoint","skippedInlineObject","block","value","isTextBlock","child","children","isSpan","text","length","spanSelectionPointToBlockOffset","blockKey","spanKey","getBlockStartPoint","node","getSelectionEndPoint","selection","backward","anchor","focus","getSelectionStartPoint","getTextBlockText","map","join","isTypedObject","object","isRecord","_type","parseBlocks","blocks","options","Array","isArray","flatMap","parsedBlock","parseBlock","parseTextBlock","parseBlockObject","blockObject","schemaType","schema","blockObjects","find","name","parseObject","keyGenerator","isListBlock","level","undefined","listItem","customFields","key","Object","keys","validateFields","fields","some","field","unparsedMarkDefs","markDefs","markDefKeyMap","Map","markDef","annotations","parsedAnnotation","set","parseSpan","span","parseInlineObject","inlineObject","filter","marks","removeUnusedMarkDefs","includes","style","styles","defaultStyle","console","error","lists","list","mark","markDefKey","get","decorators","decorator","inlineObjects","parseAnnotation","annotation","values","reduce","fieldValues","fieldValue","defaultKeyGenerator","randomKey","getByteHexTable","table","i","toString","slice","whatwgRNG","rnds8","Uint8Array","getRandomValues","str","n","sliceBlocks","startBlock","middleBlocks","endBlock","startPoint","endPoint","startBlockKey","startChildKey","endBlockKey","endChildKey","push","parsedStartBlock","parsedEndBlock"],"mappings":"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"}