"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var Schema$1 = require("./_chunks-cjs/Schema.js"), cloneDeep = require("lodash/cloneDeep.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var cloneDeep__default = /* @__PURE__ */ _interopDefaultCompat(cloneDeep);
const FIELD_REF = Symbol("FIELD_REF"), ruleConstraintTypes = [
  "Array",
  "Boolean",
  "Date",
  "Number",
  "Object",
  "String"
], Rule = class Rule2 {
  static FIELD_REF = FIELD_REF;
  static array = (def) => new Rule2(def).type("Array");
  static object = (def) => new Rule2(def).type("Object");
  static string = (def) => new Rule2(def).type("String");
  static number = (def) => new Rule2(def).type("Number");
  static boolean = (def) => new Rule2(def).type("Boolean");
  static dateTime = (def) => new Rule2(def).type("Date");
  static valueOfField = (path) => ({
    type: FIELD_REF,
    path
  });
  _type = void 0;
  _level = void 0;
  _required = void 0;
  _typeDef = void 0;
  _message = void 0;
  _rules = [];
  _fieldRules = void 0;
  constructor(typeDef) {
    this._typeDef = typeDef, this.reset();
  }
  _mergeRequired(next) {
    if (this._required === "required" || next._required === "required") return "required";
    if (this._required === "optional" || next._required === "optional") return "optional";
  }
  // Alias to static method, since we often have access to an _instance_ of a rule but not the actual Rule class
  valueOfField = Rule2.valueOfField.bind(Rule2);
  error(message) {
    const rule = this.clone();
    return rule._level = "error", rule._message = message || void 0, rule;
  }
  warning(message) {
    const rule = this.clone();
    return rule._level = "warning", rule._message = message || void 0, rule;
  }
  info(message) {
    const rule = this.clone();
    return rule._level = "info", rule._message = message || void 0, rule;
  }
  reset() {
    return this._type = this._type || void 0, this._rules = (this._rules || []).filter((rule) => rule.flag === "type"), this._message = void 0, this._required = void 0, this._level = "error", this._fieldRules = void 0, this;
  }
  isRequired() {
    return this._required === "required";
  }
  clone() {
    const rule = new Rule2();
    return rule._type = this._type, rule._message = this._message, rule._required = this._required, rule._rules = cloneDeep__default.default(this._rules), rule._level = this._level, rule._fieldRules = this._fieldRules, rule._typeDef = this._typeDef, rule;
  }
  cloneWithRules(rules) {
    const rule = this.clone(), newRules = /* @__PURE__ */ new Set();
    return rules.forEach((curr) => {
      curr.flag === "type" && (rule._type = curr.constraint), newRules.add(curr.flag);
    }), rule._rules = rule._rules.filter((curr) => {
      const disallowDuplicate = ["type", "uri", "email"].includes(curr.flag), isDuplicate = newRules.has(curr.flag);
      return !(disallowDuplicate && isDuplicate);
    }).concat(rules), rule;
  }
  merge(rule) {
    if (this._type && rule._type && this._type !== rule._type)
      throw new Error("merge() failed: conflicting types");
    const newRule = this.cloneWithRules(rule._rules);
    return newRule._type = this._type || rule._type, newRule._message = this._message || rule._message, newRule._required = this._mergeRequired(rule), newRule._level = this._level === "error" ? rule._level : this._level, newRule;
  }
  // Validation flag setters
  type(targetType) {
    const type = `${targetType.slice(0, 1).toUpperCase()}${targetType.slice(1)}`;
    if (!ruleConstraintTypes.includes(type))
      throw new Error(`Unknown type "${targetType}"`);
    const rule = this.cloneWithRules([{ flag: "type", constraint: type }]);
    return rule._type = type, rule;
  }
  all(children) {
    return this.cloneWithRules([{ flag: "all", constraint: children }]);
  }
  either(children) {
    return this.cloneWithRules([{ flag: "either", constraint: children }]);
  }
  // Shared rules
  optional() {
    const rule = this.cloneWithRules([{ flag: "presence", constraint: "optional" }]);
    return rule._required = "optional", rule;
  }
  required() {
    const rule = this.cloneWithRules([{ flag: "presence", constraint: "required" }]);
    return rule._required = "required", rule;
  }
  custom(fn, options = {}) {
    return options.bypassConcurrencyLimit && Object.assign(fn, { bypassConcurrencyLimit: !0 }), this.cloneWithRules([{ flag: "custom", constraint: fn }]);
  }
  min(len) {
    return this.cloneWithRules([{ flag: "min", constraint: len }]);
  }
  max(len) {
    return this.cloneWithRules([{ flag: "max", constraint: len }]);
  }
  length(len) {
    return this.cloneWithRules([{ flag: "length", constraint: len }]);
  }
  valid(value) {
    const values = Array.isArray(value) ? value : [value];
    return this.cloneWithRules([{ flag: "valid", constraint: values }]);
  }
  // Numbers only
  integer() {
    return this.cloneWithRules([{ flag: "integer" }]);
  }
  precision(limit) {
    return this.cloneWithRules([{ flag: "precision", constraint: limit }]);
  }
  positive() {
    return this.cloneWithRules([{ flag: "min", constraint: 0 }]);
  }
  negative() {
    return this.cloneWithRules([{ flag: "lessThan", constraint: 0 }]);
  }
  greaterThan(num) {
    return this.cloneWithRules([{ flag: "greaterThan", constraint: num }]);
  }
  lessThan(num) {
    return this.cloneWithRules([{ flag: "lessThan", constraint: num }]);
  }
  // String only
  uppercase() {
    return this.cloneWithRules([{ flag: "stringCasing", constraint: "uppercase" }]);
  }
  lowercase() {
    return this.cloneWithRules([{ flag: "stringCasing", constraint: "lowercase" }]);
  }
  regex(pattern, a, b) {
    const name = typeof a == "string" ? a : a?.name ?? b?.name, invert = typeof a == "string" ? !1 : a?.invert ?? b?.invert, constraint = {
      pattern,
      name,
      invert: invert || !1
    };
    return this.cloneWithRules([{ flag: "regex", constraint }]);
  }
  email() {
    return this.cloneWithRules([{ flag: "email" }]);
  }
  uri(opts) {
    const optsScheme = opts?.scheme || ["http", "https"], schemes = Array.isArray(optsScheme) ? optsScheme : [optsScheme];
    if (!schemes.length)
      throw new Error("scheme must have at least 1 scheme specified");
    const constraint = {
      options: {
        scheme: schemes.map((scheme) => {
          if (!(scheme instanceof RegExp) && typeof scheme != "string")
            throw new Error("scheme must be a RegExp or a String");
          return typeof scheme == "string" ? new RegExp(`^${escapeRegex(scheme)}$`) : scheme;
        }),
        allowRelative: opts?.allowRelative || !1,
        relativeOnly: opts?.relativeOnly || !1,
        allowCredentials: opts?.allowCredentials || !1
      }
    };
    return this.cloneWithRules([{ flag: "uri", constraint }]);
  }
  // Array only
  unique() {
    return this.cloneWithRules([{ flag: "unique" }]);
  }
  // Objects only
  reference() {
    return this.cloneWithRules([{ flag: "reference" }]);
  }
  fields(rules) {
    if (this._type !== "Object")
      throw new Error("fields() can only be called on an object type");
    const rule = this.cloneWithRules([]);
    return rule._fieldRules = rules, rule;
  }
  assetRequired() {
    const base = getBaseType(this._typeDef);
    let assetType;
    return base && ["image", "file"].includes(base.name) ? assetType = base.name === "image" ? "image" : "file" : assetType = "asset", this.cloneWithRules([{ flag: "assetRequired", constraint: { assetType } }]);
  }
  media(fn) {
    return this.cloneWithRules([{ flag: "media", constraint: fn }]);
  }
  /**
   * The validate method is not implemented in the base Rule class.
   * It should be implemented by extending this class or injecting validation logic.
   */
  async validate(value, options) {
    throw new Error("validate() method must be implemented by extending Rule class");
  }
};
function getBaseType(type) {
  return type && type.type ? getBaseType(type.type) : type;
}
function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
const Schema = Schema$1.Schema;
exports.default = Schema$1.DeprecatedDefaultSchema;
exports.Rule = Rule;
exports.Schema = Schema;
//# sourceMappingURL=index.js.map
