import { jsx } from "react/jsx-runtime";
import SanityLiveClientComponent from "@sanity/next-loader/client-components/live";
import SanityLiveStreamClientComponent from "@sanity/next-loader/client-components/live-stream";
import { draftMode, cookies } from "next/headers.js";
import { sanitizePerspective, perspectiveCookieName } from "./_chunks-es/utils.js";
import { isCorsOriginError } from "./_chunks-es/isCorsOriginError.js";
async function resolveCookiePerspective() {
  return (await draftMode()).isEnabled ? (await cookies()).has(perspectiveCookieName) ? sanitizePerspective((await cookies()).get(perspectiveCookieName)?.value, "drafts") : "drafts" : "published";
}
function defineLive(config) {
  const {
    client: _client,
    serverToken,
    browserToken,
    fetchOptions,
    stega: stegaEnabled = !0
  } = config;
  if (!_client)
    throw new Error("`client` is required for `defineLive` to function");
  process.env.NODE_ENV !== "production" && !serverToken && serverToken !== !1 && console.warn(
    "No `serverToken` provided to `defineLive`. This means that only published content will be fetched and respond to live events. You can silence this warning by setting `serverToken: false`."
  ), process.env.NODE_ENV !== "production" && !browserToken && browserToken !== !1 && console.warn(
    "No `browserToken` provided to `defineLive`. This means that live previewing drafts will only work when using the Presentation Tool in your Sanity Studio. To support live previewing drafts stand-alone, provide a `browserToken`. It is shared with the browser so it should only have Viewer rights or lower. You can silence this warning by setting `browserToken: false`."
  );
  const client = _client.withConfig({ allowReconfigure: !1, useCdn: !1 }), { token: originalToken } = client.config(), studioUrlDefined = typeof client.config().stega.studioUrl < "u", sanityFetch = async function({
    query,
    params = {},
    stega: _stega,
    tags = ["sanity"],
    perspective: _perspective,
    tag,
    requestTag = tag ?? "next-loader.fetch"
  }) {
    const stega = _stega ?? (stegaEnabled && studioUrlDefined && (await draftMode()).isEnabled), perspective = _perspective ?? await resolveCookiePerspective(), useCdn = perspective === "published", revalidate = fetchOptions?.revalidate !== void 0 ? fetchOptions.revalidate : process.env.NODE_ENV === "production" ? !1 : void 0, { syncTags } = await client.fetch(query, await params, {
      filterResponse: !1,
      perspective,
      stega: !1,
      returnQuery: !1,
      next: { revalidate, tags: [...tags, "sanity:fetch-sync-tags"] },
      useCdn,
      cacheMode: useCdn ? "noStale" : void 0,
      tag: [requestTag, "fetch-sync-tags"].filter(Boolean).join(".")
    }), cacheTags = [...tags, ...syncTags?.map((tag2) => `sanity:${tag2}`) || []], { result, resultSourceMap } = await client.fetch(query, await params, {
      filterResponse: !1,
      perspective,
      stega,
      token: perspective !== "published" && serverToken ? serverToken : originalToken,
      next: { revalidate, tags: cacheTags },
      useCdn,
      cacheMode: useCdn ? "noStale" : void 0,
      tag: requestTag
    });
    return { data: result, sourceMap: resultSourceMap || null, tags: cacheTags };
  };
  return {
    sanityFetch,
    SanityLive: async function(props) {
      const {
        // handleDraftModeAction = handleDraftModeActionMissing
        refreshOnMount,
        refreshOnFocus,
        refreshOnReconnect,
        tag,
        requestTag = tag,
        onError,
        onGoAway,
        intervalOnGoAway,
        revalidateSyncTags
      } = props, { projectId, dataset, apiHost, apiVersion, useProjectHostname, requestTagPrefix } = client.config(), { isEnabled: isDraftModeEnabled } = await draftMode();
      return /* @__PURE__ */ jsx(
        SanityLiveClientComponent,
        {
          projectId,
          dataset,
          apiHost,
          apiVersion,
          useProjectHostname,
          requestTagPrefix,
          requestTag,
          token: typeof browserToken == "string" && isDraftModeEnabled ? browserToken : void 0,
          draftModeEnabled: isDraftModeEnabled,
          draftModePerspective: await resolveCookiePerspective(),
          refreshOnMount,
          refreshOnFocus,
          refreshOnReconnect,
          onError,
          onGoAway,
          intervalOnGoAway,
          revalidateSyncTags
        }
      );
    },
    SanityLiveStream: async function(props) {
      const {
        query,
        params,
        perspective: _perspective,
        stega: _stega,
        tags,
        children,
        tag,
        requestTag = tag ?? "next-loader.live-stream.fetch"
      } = props, {
        data,
        sourceMap,
        tags: cacheTags
      } = await sanityFetch({
        query,
        params,
        tags,
        perspective: _perspective,
        stega: _stega,
        requestTag
      }), { isEnabled: isDraftModeEnabled } = await draftMode();
      if (isDraftModeEnabled) {
        const stega = _stega ?? (stegaEnabled && studioUrlDefined && (await draftMode()).isEnabled), perspective = _perspective ?? await resolveCookiePerspective(), { projectId, dataset } = client.config();
        return /* @__PURE__ */ jsx(
          SanityLiveStreamClientComponent,
          {
            projectId,
            dataset,
            query,
            params: await params,
            perspective,
            stega,
            initial: children({ data, sourceMap, tags: cacheTags }),
            children
          }
        );
      }
      return children({ data, sourceMap, tags: cacheTags });
    }
    // verifyPreviewSecret
  };
}
export {
  defineLive,
  isCorsOriginError
};
//# sourceMappingURL=index.js.map
